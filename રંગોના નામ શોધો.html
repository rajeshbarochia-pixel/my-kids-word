import React, { useState, useEffect, useRef, useCallback } from 'react';
import confetti from 'canvas-confetti';
import { WORDS, GUJARATI_TITLE, GRID_SIZE, AUTHOR_CREDIT } from './constants';
import { generateGameGrid, getCellsBetween, isStraightLine } from './utils/generator';
import { GridCell, WordData, Coordinate, GameState } from './types';
import { StarIcon } from './components/StarIcon';

// Mapped helper to convert bg-color to text-color for the star fill
const getFillClass = (bgClass: string) => {
    if (bgClass.includes('white')) return 'text-white';
    return bgClass.replace('bg-', 'text-');
};

const App: React.FC = () => {
  const [grid, setGrid] = useState<GridCell[][]>([]);
  const [placedWords, setPlacedWords] = useState<Map<string, WordData>>(new Map());
  const [foundWords, setFoundWords] = useState<string[]>([]);
  const [selection, setSelection] = useState<{ start: Coordinate; end: Coordinate } | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [gameState, setGameState] = useState<GameState>(GameState.PLAYING);
  
  const gridRef = useRef<HTMLDivElement>(null);

  const startNewGame = useCallback(() => {
    const { grid: newGrid, placedWords: newPlacedWords } = generateGameGrid();
    setGrid(newGrid);
    setPlacedWords(newPlacedWords);
    setFoundWords([]);
    setSelection(null);
    setGameState(GameState.PLAYING);
  }, []);

  useEffect(() => {
    startNewGame();
  }, [startNewGame]);

  useEffect(() => {
    if (foundWords.length > 0 && foundWords.length === WORDS.length) {
      setGameState(GameState.WON);
      const duration = 3000;
      const end = Date.now() + duration;

      const frame = () => {
        confetti({
          particleCount: 5,
          angle: 60,
          spread: 55,
          origin: { x: 0 },
          colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff']
        });
        confetti({
          particleCount: 5,
          angle: 120,
          spread: 55,
          origin: { x: 1 },
          colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff']
        });

        if (Date.now() < end) {
          requestAnimationFrame(frame);
        }
      };
      frame();
    }
  }, [foundWords]);

  const handlePointerDown = (rowIndex: number, colIndex: number, e: React.PointerEvent) => {
    e.preventDefault(); 
    if (gameState === GameState.WON) return;
    
    setIsDragging(true);
    setSelection({
      start: { row: rowIndex, col: colIndex },
      end: { row: rowIndex, col: colIndex }
    });
  };

  const handlePointerMove = (e: React.PointerEvent) => {
    if (!isDragging || gameState === GameState.WON) return;
    e.preventDefault();
    
    // Use elementFromPoint to handle touch/mouse drag uniformly
    // This fixes the issue where touch capture prevents other cells from receiving events
    const element = document.elementFromPoint(e.clientX, e.clientY);
    const cell = element?.closest('[data-grid-cell="true"]');

    if (cell) {
        const row = parseInt(cell.getAttribute('data-row') || '-1');
        const col = parseInt(cell.getAttribute('data-col') || '-1');

        if (row >= 0 && col >= 0) {
            setSelection(prev => {
                if (!prev) return null;
                // Avoid state update if position hasn't changed
                if (prev.end.row === row && prev.end.col === col) return prev;
                
                return {
                    ...prev,
                    end: { row, col }
                };
            });
        }
    }
  };

  const handlePointerUp = () => {
    if (!isDragging || !selection) return;
    setIsDragging(false);

    const { start, end } = selection;
    
    if (!isStraightLine(start, end)) {
      setSelection(null);
      return;
    }

    const selectedCells = getCellsBetween(start, end);
    const selectedWord = selectedCells.map(c => grid[c.row][c.col].char).join('');
    const reversedWord = selectedWord.split('').reverse().join('');

    let matchedWord = '';
    if (placedWords.has(selectedWord)) matchedWord = selectedWord;
    else if (placedWords.has(reversedWord)) matchedWord = reversedWord;

    if (matchedWord && !foundWords.includes(matchedWord)) {
      setFoundWords(prev => [...prev, matchedWord]);
      const wordData = placedWords.get(matchedWord);
      
      setGrid(prev => {
        const newGrid = [...prev.map(row => [...row])];
        selectedCells.forEach(cell => {
          newGrid[cell.row][cell.col].found = true;
          newGrid[cell.row][cell.col].foundColor = wordData?.twColor || 'bg-green-300';
        });
        return newGrid;
      });
    }

    setSelection(null);
  };

  const getCellStyle = (rowIndex: number, colIndex: number) => {
    const cell = grid[rowIndex][colIndex];
    
    let baseClass = "w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 flex items-center justify-center text-sm sm:text-lg font-bold rounded cursor-pointer select-none transition-colors duration-150 border border-gray-100 ";
    
    let isSelected = false;
    if (selection && isStraightLine(selection.start, selection.end)) {
        const points = getCellsBetween(selection.start, selection.end);
        isSelected = points.some(p => p.row === rowIndex && p.col === colIndex);
    }

    if (cell.found) {
        const bg = cell.foundColor || 'bg-green-400';
        const isLight = bg.includes('white') || bg.includes('yellow');
        baseClass += `${bg} ${isLight ? 'text-black' : 'text-white'} shadow-sm`;
    } else if (isSelected) {
        baseClass += "bg-blue-200 text-blue-900 scale-105 transform shadow-md";
    } else {
        baseClass += "bg-white hover:bg-gray-50 text-gray-800 shadow-sm";
    }

    return baseClass;
  };

  return (
    <div 
      className="min-h-screen flex flex-col items-center py-6 px-4 touch-none select-none"
      onPointerUp={handlePointerUp}
      // Add pointer move here to catch moves outside the grid container but inside the app if needed
    >
      <div className="bg-white rounded-xl shadow-lg p-4 mb-6 w-full max-w-lg border-t-8 border-indigo-500">
        <h1 className="text-2xl sm:text-3xl font-bold text-center text-indigo-900 gujarati-text mb-2">
          {GUJARATI_TITLE}
        </h1>
        <div className="flex justify-between items-center px-2">
            <span className="text-gray-500 text-sm font-semibold">
                Score: {foundWords.length} / {WORDS.length}
            </span>
            <button 
                onClick={startNewGame}
                className="px-4 py-1 bg-indigo-100 hover:bg-indigo-200 text-indigo-700 text-sm font-bold rounded-full transition-colors"
            >
                New Game
            </button>
        </div>
      </div>

      <div className="flex flex-col md:flex-row gap-8 items-start w-full max-w-4xl justify-center">
        
        <div 
            ref={gridRef}
            className="p-3 bg-indigo-50 rounded-xl shadow-inner border-4 border-indigo-200 mx-auto"
            style={{ touchAction: 'none' }}
            onPointerMove={handlePointerMove} // Moved logic here
            onPointerLeave={handlePointerUp} // End selection if they drag out of grid
        >
          <div 
            className="grid gap-1"
            style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, minmax(0, 1fr))` }}
          >
            {grid.map((row, rIndex) => (
              row.map((cell, cIndex) => (
                <div
                  key={`${rIndex}-${cIndex}`}
                  className={getCellStyle(rIndex, cIndex)}
                  onPointerDown={(e) => handlePointerDown(rIndex, cIndex, e)}
                  data-grid-cell="true"
                  data-row={rIndex}
                  data-col={cIndex}
                >
                  {cell.char}
                </div>
              ))
            ))}
          </div>
        </div>

        <div className="bg-white rounded-xl shadow-md p-6 w-full md:w-auto flex-1 max-w-sm mx-auto">
          <h2 className="text-lg font-bold text-gray-700 mb-4 border-b pb-2">Colors to Find</h2>
          <div className="grid grid-cols-2 gap-4">
            {WORDS.map((wordData) => {
              const isFound = foundWords.includes(wordData.word);
              return (
                <div 
                    key={wordData.word} 
                    className={`flex items-center gap-3 transition-all duration-300 ${isFound ? 'opacity-40 grayscale' : 'opacity-100'}`}
                >
                  <StarIcon 
                    colorClass={getFillClass(wordData.twColor)} 
                    className={isFound ? 'scale-90' : 'animate-pulse-slow'}
                  />
                  <span className={`font-bold text-lg ${isFound ? 'text-gray-400 line-through' : 'text-gray-700'}`}>
                    {wordData.word.toLowerCase()}
                  </span>
                </div>
              );
            })}
          </div>
        </div>

      </div>

      <footer className="mt-auto pt-8 text-center text-gray-400 font-medium text-sm">
        {AUTHOR_CREDIT}
      </footer>

      {gameState === GameState.WON && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50 backdrop-blur-sm">
          <div className="bg-white rounded-2xl p-8 max-w-sm w-full text-center shadow-2xl transform animate-bounce-in">
            <h2 className="text-3xl font-bold text-indigo-600 mb-4 gujarati-text">ખૂબ સરસ! (Great Job!)</h2>
            <p className="text-gray-600 mb-6">You found all the colors!</p>
            <button 
              onClick={startNewGame}
              className="w-full py-3 bg-indigo-600 text-white rounded-xl font-bold text-lg hover:bg-indigo-700 transition-colors shadow-lg hover:shadow-xl transform hover:-translate-y-1"
            >
              Play Again
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default App;
