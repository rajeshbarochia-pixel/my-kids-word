<!DOCTYPE html>
<html lang="gu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ркЕрккрлВрк░рлНркгрк╛ркВркХ рк░ркоркд</title>
    
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .game-container {
            width: 100%;
            max-width: 480px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        .card {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }
        canvas {
            border: 3px solid #3b82f6;
            border-radius: 0.75rem;
            touch-action: manipulation; /* Improves touch handling */
        }
        /* Style for the fraction display */
        .fraction-display {
            display: inline-block;
            font-size: 3rem;
            line-height: 1;
            font-weight: 700;
            color: #1e3a8a;
            margin: 0.5rem 0;
        }
        .fraction-display .numerator {
            border-bottom: 4px solid #1e3a8a;
            padding-bottom: 2px;
        }
        .fraction-display .denominator {
            padding-top: 2px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="card">
            <h1 class="text-3xl font-bold text-center text-blue-800 mb-2">ркЕрккрлВрк░рлНркгрк╛ркВркХ рк░ркоркд</h1>
            <p class="text-sm text-center text-gray-500 mb-6">Created by:Rajesh Barochia</p>

            <!-- Score and Question Status -->
            <div class="flex justify-between items-center text-lg font-medium mb-4">
                <div class="text-gray-700">рк╕рлНркХрлЛрк░: <span id="scoreDisplay" class="font-bold text-green-600">0</span></div>
                <div class="text-gray-700">рккрлНрк░рк╢рлНрки: <span id="questionCountDisplay" class="font-bold text-blue-600">0</span></div>
            </div>

            <!-- Instruction and Fraction Display -->
            <div class="text-center mb-6">
                <p class="text-xl font-semibold text-gray-800 mb-2">ркЕрккрлВрк░рлНркгрк╛ркВркХ ркжрк░рлНрк╢рк╛рк╡рк╡рк╛ ркорк╛ркЯрлЗ ркнрк╛ркЧрлЛркирлЗ рк░ркВркЧ ркХрк░рлЛ:</p>
                <div id="fractionTarget" class="fraction-display mx-auto">
                    <!-- Fraction will be injected here -->
                </div>
            </div>

            <!-- Canvas for Interactive Shape -->
            <div class="w-full h-auto flex justify-center mb-6">
                <canvas id="gameCanvas" width="300" height="300" class="w-full max-w-xs"></canvas>
            </div>

            <!-- Feedback Message -->
            <p id="feedback" class="text-center text-lg font-bold h-6 mb-4"></p>

            <!-- Action Button -->
            <div class="flex justify-center">
                <button id="nextButton" class="w-full py-3 px-6 bg-blue-500 hover:bg-blue-600 text-white font-bold rounded-xl transition shadow-lg shadow-blue-300/50" onclick="checkAnswer()">
                    ркЬрк╡рк╛ркм ркдрккрк╛рк╕рлЛ
                </button>
            </div>
        </div>
    </div>

    <script>
        // ркЧрлНрк▓рлЛркмрк▓ рк╡рлЗрк░рлАркПркмрк▓рлНрк╕
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const questionCountDisplay = document.getElementById('questionCountDisplay');
        const fractionTarget = document.getElementById('fractionTarget');
        const feedback = document.getElementById('feedback');
        const nextButton = document.getElementById('nextButton');

        let score = 0;
        let questionCount = 0;
        let currentQuestion = null;
        let shadedParts = []; // ркпрлБркЭрк░ ркжрлНрк╡рк╛рк░рк╛ рк░ркВркЧрк╛ркпрлЗрк▓рк╛ ркнрк╛ркЧрлЛркирк╛ ркЗркирлНркбрлЗркХрлНрк╕
        let questionsPlayedIndices = []; // рк░ркорк╛ркИ ркЧркпрлЗрк▓рк╛ рккрлНрк░рк╢рлНркирлЛркирк╛ ркЗркирлНркбрлЗркХрлНрк╕ркирлЛ ркЯрлНрк░рлЗркХ рк░рк╛ркЦрк╡рк╛
        let currentShapeColor = '#f0f4f8'; // ркЖркХрк╛рк░ркирлЛ рк╡рк░рлНркдркорк╛рки рккрлГрк╖рлНркаркнрлВркорк┐ рк░ркВркЧ

        // рккрлНрк░рк╢рлНркирлЛркирлЛ ркбрлЗркЯрк╛ (ркЕрккрлВрк░рлНркгрк╛ркВркХ ркЕркирлЗ ркЖркХрк╛рк░ркирлЛ рккрлНрк░ркХрк╛рк░)
        // ркирлЛркВркз: ркдрк╛рк░рк╛ ркЖркХрк╛рк░ркирлЗ рк╣рк╡рлЗ 5 рк╕ркорк╛рки ркнрк╛ркЧрлЛркорк╛ркВ рк╡рк┐ркнрк╛ркЬрк┐ркд ркХрк░рк╡рк╛ркорк╛ркВ ркЖрк╡рлНркпрлЛ ркЫрлЗ.
        const allQuestions = [
            // Row 1
            { n: 1, d: 2, type: 'circle', segments: 2 }, // 1/2
            { n: 2, d: 5, type: 'polygon', sides: 5, segments: 5 }, // 2/5 (Pentagon)
            // Row 2
            { n: 1, d: 5, type: 'star', segments: 5 }, // 1/5 (Star - рк╣рк╡рлЗ 5 ркорлЛркЯрк╛ ркнрк╛ркЧрлЛ) <--- рк╕рлБркзрк╛рк░рлЗрк▓рлЛ ркнрк╛ркЧ
            { n: 3, d: 4, type: 'rect', segments: 4 }, // 3/4 (Square grid)
            // Row 3
            { n: 1, d: 2, type: 'rect', segments: 2, horizontal: true }, // 1/2 (Horizontal rectangle)
            { n: 5, d: 6, type: 'circle', segments: 6 }, // 5/6 (Circle 6 segments)
            // Row 4
            { n: 3, d: 8, type: 'circle', segments: 8 }, // 3/8 (Octagon-like circle segments)
            { n: 1, d: 6, type: 'triangle', segments: 6 }, // 1/6 (Large triangle, divided into 6)
            // Row 5
            { n: 1, d: 4, type: 'triangle', segments: 4 }, // 1/4 (Large triangle, divided into 4)
        ];

        // рк░ркВркЧркмрлЗрк░ркВркЧрлА рккрлГрк╖рлНркаркнрлВркорк┐ рк░ркВркЧрлЛркирлА ркпрк╛ркжрлА
        const colorfulBackgrounds = [
            '#FFDDC1', // Light Peach
            '#FFABAB', // Light Red
            '#FFDA9E', // Light Orange
            '#FFFFB3', // Light Yellow
            '#D0F0C0', // Light Green
            '#A7D9D9', // Light Cyan
            '#ADD8E6', // Light Blue
            '#C9A0DC', // Light Purple
            '#F0E68C', // Khaki
            '#F08080'  // Light Coral
        ];

        // ------------------------------------------------------------------
        // рк░рлЗркирлНркбрко рккрлНрк░рк╢рлНрки рккрк╕ркВркж ркХрк░рлЛ
        // ------------------------------------------------------------------
        function getNextQuestion() {
            // ркЬрлЛ ркмркзрк╛ рккрлНрк░рк╢рлНркирлЛ рк░ркорк╛ркИ ркЧркпрк╛ рк╣рлЛркп, ркдрлЛ ркЗркирлНркбрлЗркХрлНрк╕ рк░рлАрк╕рлЗркЯ ркХрк░рлЛ
            if (questionsPlayedIndices.length === allQuestions.length) {
                questionsPlayedIndices = [];
            }
            
            let availableIndices = allQuestions
                .map((_, index) => index)
                .filter(index => !questionsPlayedIndices.includes(index));
            
            // ркЬрлЛ ркХрлЛркИ ркЙрккрк▓ркмрлНркз рки рк╣рлЛркп (ркорлЛркЯрк╛ркнрк╛ркЧрлЗ рки ркерк╡рлБркВ ркЬрлЛркИркП), ркмркзрк╛ркорк╛ркВркерлА рккрк╕ркВркж ркХрк░рлЛ
            if (availableIndices.length === 0) {
                 availableIndices = allQuestions.map((_, index) => index);
            }

            const randomIndexInAvailable = Math.floor(Math.random() * availableIndices.length);
            const questionIndex = availableIndices[randomIndexInAvailable];
            const question = allQuestions[questionIndex];

            questionsPlayedIndices.push(questionIndex); // рккрлНрк░рк╢рлНркиркирк╛ ркЗркирлНркбрлЗркХрлНрк╕ркирлЗ рк░ркорк╛ркИ ркЧркпрлЗрк▓рк╛ ркдрк░рлАркХрлЗ ркорк╛рк░рлНркХ ркХрк░рлЛ
            return question;
        }

        // ------------------------------------------------------------------
        // ркирк╡рлА ркЧрлЗрко рк╢рк░рлВ ркХрк░рлЛ (рк╕рлНркХрлЛрк░ рк░рлАрк╕рлЗркЯ ркХрк░рлАркирлЗ)
        // ------------------------------------------------------------------
        function startNewRound() {
            score = 0;
            questionCount = 0;
            questionsPlayedIndices = []; 
            loadNextQuestion(); // рккрлНрк░ркерко рккрлНрк░рк╢рлНрки рк▓рлЛркб ркХрк░рлЛ
        }

        // ------------------------------------------------------------------
        // ркЖркЧрк▓рлЛ рккрлНрк░рк╢рлНрки рк▓рлЛркб ркХрк░рлЛ
        // ------------------------------------------------------------------
        function loadNextQuestion() {
            currentQuestion = getNextQuestion();
            questionCount++; 
            shadedParts = []; // рк░ркВркЧрк╛ркпрлЗрк▓рк╛ ркнрк╛ркЧрлЛ рк░рлАрк╕рлЗркЯ ркХрк░рлЛ
            
            // ркЖркХрк╛рк░ ркорк╛ркЯрлЗ рк░рлЗркирлНркбрко рккрлГрк╖рлНркаркнрлВркорк┐ рк░ркВркЧ рккрк╕ркВркж ркХрк░рлЛ
            currentShapeColor = colorfulBackgrounds[Math.floor(Math.random() * colorfulBackgrounds.length)];

            // ркЕрккрлВрк░рлНркгрк╛ркВркХ ркбрк┐рк╕рлНрккрлНрк▓рлЗ ркЕрккркбрлЗркЯ ркХрк░рлЛ (ркжрк╛.ркд., 3/4)
            fractionTarget.innerHTML = `
                <div class="numerator">${currentQuestion.n}</div>
                <div class="denominator">${currentQuestion.d}</div>
            `;
            
            // UI ркЕрккркбрлЗркЯ ркХрк░рлЛ
            scoreDisplay.textContent = score;
            questionCountDisplay.textContent = questionCount;
            feedback.textContent = '';
            feedback.className = 'text-center text-lg font-bold h-6 mb-4'; 
            
            nextButton.textContent = 'ркЬрк╡рк╛ркм ркдрккрк╛рк╕рлЛ';
            nextButton.onclick = checkAnswer;

            // ркЖркХрк╛рк░ ркжрлЛрк░рлЛ
            drawShape();
        }

        // ------------------------------------------------------------------
        // ркХрлЗркирк╡рк╛рк╕ рккрк░ ркЖркХрк╛рк░ ркжрлЛрк░рлЛ
        // ------------------------------------------------------------------
        function drawShape() {
            const { segments, type } = currentQuestion;
            const size = canvas.width;
            const center = size / 2;
            ctx.clearRect(0, 0, size, size);
            
            // ркбрлНрк░рлЛркЗркВркЧ рклркВркХрлНрк╢рки ркЬрлЗ ркжрк░рлЗркХ рк╕рлЗркЧркорлЗркирлНркЯ ркорк╛ркЯрлЗ ркПркХ рккрк╛рке рккрк░ркд ркХрк░рлЗ ркЫрлЗ
            const segmentPaths = getSegmentPaths(type, segments, size, center);

            segmentPaths.forEach((path, i) => {
                ctx.beginPath();
                ctx.strokeStyle = '#1e3a8a';
                ctx.lineWidth = 2;
                
                // рккрк╛рке ркжрлЛрк░рлЛ
                path.forEach((p, index) => {
                    if (index === 0) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        if (p.arc) {
                            // рк╡рк░рлНркдрлБрк│ рк╕рлЗркЧркорлЗркирлНркЯрлНрк╕ ркорк╛ркЯрлЗ arc() ркирлЛ ркЙрккркпрлЛркЧ ркХрк░рлЛ
                            ctx.arc(p.cx, p.cy, p.r, p.start, p.end);
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    }
                });

                // рк╡рк░рлНркдрлБрк│/рк▓ркВркмркЪрлЛрк░рк╕ ркмркВркз ркХрк░рлЛ
                if (type === 'circle' || type === 'polygon' || type === 'triangle' || type === 'rect' || type === 'star') {
                    ctx.closePath();
                }

                // рк░ркВркЧрк╛ркпрлЗрк▓рлЛ ркнрк╛ркЧ
                if (shadedParts.includes(i)) {
                    ctx.fillStyle = '#60a5fa'; // рк╡рк╛ркжрк│рлА рк░ркВркЧ
                } else {
                    ctx.fillStyle = currentShapeColor; // ркЖркХрк╛рк░ркирлЛ рк░рлЗркирлНркбрко рккрлГрк╖рлНркаркнрлВркорк┐ рк░ркВркЧ
                }

                ctx.fill();
                ctx.stroke();
            });
        }

        // ркЖркХрк╛рк░ркирк╛ ркЖркзрк╛рк░рлЗ рк╕рлЗркЧркорлЗркирлНркЯ рккрк╛ркерлНрк╕ркирлА ркЧркгркдрк░рлА
        function getSegmentPaths(type, segments, size, center) {
            const paths = [];
            const margin = 10;
            const effectiveSize = size - 2 * margin;
            const effectiveCenter = center;

            if (type === 'rect' && segments === 4) { // 4-ркнрк╛ркЧ ркЪрлЛрк░рк╕
                const segmentSize = effectiveSize / 2;
                paths.push([ // Top Left
                    { x: margin, y: margin }, { x: center, y: margin }, { x: center, y: center }, { x: margin, y: center }
                ]);
                paths.push([ // Top Right
                    { x: center, y: margin }, { x: size - margin, y: margin }, { x: size - margin, y: center }, { x: center, y: center }
                ]);
                paths.push([ // Bottom Right
                    { x: center, y: center }, { x: size - margin, y: center }, { x: size - margin, y: size - margin }, { x: center, y: size - margin }
                ]);
                paths.push([ // Bottom Left
                    { x: margin, y: center }, { x: center, y: center }, { x: center, y: size - margin }, { x: margin, y: size - margin }
                ]);
            } else if (type === 'rect' && segments === 2) { // 2-ркнрк╛ркЧ рк▓ркВркмркЪрлЛрк░рк╕ (Vertical)
                const segmentWidth = effectiveSize / 2;
                paths.push([ // Left Half
                    { x: margin, y: margin }, { x: margin + segmentWidth, y: margin }, { x: margin + segmentWidth, y: size - margin }, { x: margin, y: size - margin }
                ]);
                paths.push([ // Right Half
                    { x: margin + segmentWidth, y: margin }, { x: size - margin, y: margin }, { x: size - margin, y: size - margin }, { x: margin + segmentWidth, y: size - margin }
                ]);
            } else if (type === 'rect' && segments === 2 && currentQuestion.horizontal) { // 2-ркнрк╛ркЧ рк▓ркВркмркЪрлЛрк░рк╕ (Horizontal)
                const segmentHeight = effectiveSize / 2;
                paths.push([ // Top Half
                    { x: margin, y: margin }, { x: size - margin, y: margin }, { x: size - margin, y: margin + segmentHeight }, { x: margin, y: margin + segmentHeight }
                ]);
                paths.push([ // Bottom Half
                    { x: margin, y: margin + segmentHeight }, { x: size - margin, y: margin + segmentHeight }, { x: size - margin, y: size - margin }, { x: margin, y: size - margin }
                ]);
            } else if (type === 'circle') {
                const radius = effectiveSize / 2;
                const angleStep = (2 * Math.PI) / segments;

                for (let i = 0; i < segments; i++) {
                    const startAngle = i * angleStep - Math.PI / 2; // ркЙрккрк░ркерлА рк╢рк░рлВ ркХрк░рлЛ
                    const endAngle = (i + 1) * angleStep - Math.PI / 2;

                    paths.push([
                        { x: effectiveCenter, y: effectiveCenter },
                        { arc: true, cx: effectiveCenter, cy: effectiveCenter, r: radius, start: startAngle, end: endAngle },
                        { x: effectiveCenter, y: effectiveCenter } // рк╕рлЗркирлНркЯрк░ рккрк░ рккрк╛ркЫрк╛ рклрк░рлЛ
                    ]);
                }
            } else if (type === 'polygon' && segments === 5) { // 5-ркнрк╛ркЧ рккрлЗркирлНркЯрк╛ркЧрлЛрки (рккрк╛ркВркЪ ркдрлНрк░рк┐ркХрлЛркг)
                const radius = effectiveSize / 2.5; // Slightly smaller to fit
                const angleStep = (2 * Math.PI) / segments;
                const offset = Math.PI / 2 + angleStep / 2; // Point top vertex up

                for (let i = 0; i < segments; i++) {
                    const startAngle = i * angleStep + offset;
                    const endAngle = (i + 1) * angleStep + offset;

                    const p1 = { x: effectiveCenter + radius * Math.cos(startAngle), y: effectiveCenter - radius * Math.sin(startAngle) };
                    const p2 = { x: effectiveCenter + radius * Math.cos(endAngle), y: effectiveCenter - radius * Math.sin(endAngle) };
                    
                    paths.push([
                        { x: effectiveCenter, y: effectiveCenter }, p1, p2
                    ]);
                }
            } else if (type === 'triangle' && (segments === 4 || segments === 6)) {
                // Image triangle is an equilateral triangle divided into smaller triangles.
                const h = effectiveSize * Math.sqrt(3) / 2;
                const side = effectiveSize;
                const pA = { x: effectiveCenter, y: margin }; // Top point
                const pB = { x: margin, y: size - margin }; // Bottom-left
                const pC = { x: size - margin, y: size - margin }; // Bottom-right
                const pCenter = { x: effectiveCenter, y: (pA.y + pB.y + pC.y) / 3 }; // Centroid

                if (segments === 4) {
                    // 4 segments (Central triangle + 3 outer triangles)
                    const pMidAB = { x: (pA.x + pB.x) / 2, y: (pA.y + pB.y) / 2 };
                    const pMidBC = { x: (pB.x + pC.x) / 2, y: (pB.y + pC.y) / 2 };
                    const pMidCA = { x: (pC.x + pA.x) / 2, y: (pC.y + pA.y) / 2 };

                    paths.push([pA, pMidCA, pMidAB]); // Top Triangle
                    paths.push([pB, pMidAB, pMidBC]); // Left Triangle
                    paths.push([pC, pMidBC, pMidCA]); // Right Triangle
                    paths.push([pMidAB, pMidCA, pMidBC]); // Center Triangle

                } else if (segments === 6) {
                    // 6 segments (Central point divides into 6 triangles)
                    
                    const pMidAB = { x: (pA.x + pB.x) / 2, y: (pA.y + pB.y) / 2 };
                    const pMidBC = { x: (pB.x + pC.x) / 2, y: (pB.y + pC.y) / 2 };
                    const pMidCA = { x: (pC.x + pA.x) / 2, y: (pC.y + pA.y) / 2 };

                    // 6 triangles meeting at centroid
                    paths.push([pA, pMidAB, pCenter]);
                    paths.push([pA, pMidCA, pCenter]);

                    paths.push([pB, pMidAB, pCenter]);
                    paths.push([pB, pMidBC, pCenter]);

                    paths.push([pC, pMidBC, pCenter]);
                    paths.push([pC, pMidCA, pCenter]);
                }

            } else if (type === 'star') {
                // STAR SHAPE: Now modified to 5 large, symmetrical segments (as requested for a 1/5 fraction)
                // This draws 5 kite-shaped segments from the center, ignoring the inner star lines.
                const numPoints = 5;
                const outerRadius = effectiveSize / 2.5;
                const innerRadius = outerRadius / 2.5;
                const angleStep = Math.PI / numPoints; // Angle between outer points
                const angleOffset = -Math.PI / 2; // Start from top
                
                let outerPoints = [];
                let innerPoints = [];
                
                // Calculate 5 outer and 5 inner points
                for (let i = 0; i < 2 * numPoints; i++) {
                    const r = (i % 2 === 0) ? outerRadius : innerRadius;
                    const angle = i * angleStep + angleOffset;
                    const point = {
                        x: effectiveCenter + r * Math.cos(angle),
                        y: effectiveCenter + r * Math.sin(angle)
                    };
                    if (i % 2 === 0) {
                        outerPoints.push(point);
                    } else {
                        innerPoints.push(point);
                    }
                }

                // Create 5 large kite-shaped segments meeting at the center
                for (let i = 0; i < numPoints; i++) {
                    const outerP = outerPoints[i];
                    const innerP_start = innerPoints[(i - 1 + numPoints) % numPoints]; // Previous inner point
                    const innerP_end = innerPoints[i]; // Current inner point
                    
                    paths.push([
                        { x: effectiveCenter, y: effectiveCenter }, 
                        innerP_start, 
                        outerP,
                        innerP_end
                    ]);
                }
            }

            return paths;
        }

        // ------------------------------------------------------------------
        // ркЪрлЗркХ ркХрк░рлЛ ркХрлЗ рккрлЛркИркирлНркЯ ркХркпрк╛ рк╕рлЗркЧркорлЗркирлНркЯркорк╛ркВ ркЫрлЗ
        // ------------------------------------------------------------------
        function isPointInPath(x, y, path) {
            // ркЖ рклркВркХрлНрк╢рки CANVAS ркирлЛ ркЙрккркпрлЛркЧ ркХрк░рлАркирлЗ рккрлЛркИркирлНркЯ рккрк╛ркеркирлА ркЕркВркжрк░ ркЫрлЗ ркХрлЗ ркХрлЗрко ркдрлЗ ркдрккрк╛рк╕рлЗ ркЫрлЗ
            ctx.beginPath();
            path.forEach((p, index) => {
                if (index === 0) {
                    ctx.moveTo(p.x, p.y);
                } else {
                    if (p.arc) {
                        ctx.arc(p.cx, p.cy, p.r, p.start, p.end);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                }
            });
            ctx.closePath();
            return ctx.isPointInPath(x, y);
        }

        // ------------------------------------------------------------------
        // ркХрлНрк▓рк┐ркХ/ркЯркЪ ркЗрк╡рлЗркирлНркЯ рк╣рлЗркирлНркбрк▓рк░
        // ------------------------------------------------------------------
        function handleInteraction(event) {
            // ркЬрк╡рк╛ркм ркЪрлЗркХ ркХрк░рлНркпрк╛ рккркЫрлА ркЗркирлНркЯрк░рлЗркХрлНрк╢рки ркЕркЯркХрк╛рк╡рлЛ
            if (nextButton.textContent !== 'ркЬрк╡рк╛ркм ркдрккрк╛рк╕рлЛ') {
                return;
            }

            // ркХрлЗркирк╡рк╛рк╕ркирк╛ рк╕ркВркмркВркзркорк╛ркВ ркорк╛ркЙрк╕/ркЯркЪ ркХрлЛркУрк░рлНркбрк┐ркирлЗркЯрлНрк╕ ркорлЗрк│рк╡рлЛ
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let clientX, clientY;
            if (event.touches) {
                // ркЯркЪ ркЗрк╡рлЗркирлНркЯрлНрк╕ ркорк╛ркЯрлЗ
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                // ркорк╛ркЙрк╕ ркЗрк╡рлЗркирлНркЯрлНрк╕ ркорк╛ркЯрлЗ
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            
            const { segments, type } = currentQuestion;
            const center = canvas.width / 2;
            const segmentPaths = getSegmentPaths(type, segments, canvas.width, center);
            let segmentIndex = -1;
            
            // ркжрк░рлЗркХ рк╕рлЗркЧркорлЗркирлНркЯ рккрк╛рке рккрк░ рккрлЛркИркирлНркЯркирлБркВ рккрк░рлАркХрлНрк╖ркг ркХрк░рлЛ
            for (let i = 0; i < segmentPaths.length; i++) {
                if (isPointInPath(x, y, segmentPaths[i])) {
                    segmentIndex = i;
                    break;
                }
            }
            
            // ркнрк╛ркЧркирлЗ рк░ркВркЧрлЛ ркЕркерк╡рк╛ рк░ркВркЧ ркХрк╛ркврлА ркирк╛ркЦрлЛ
            if (segmentIndex !== -1) {
                const indexInArray = shadedParts.indexOf(segmentIndex);
                if (indexInArray > -1) {
                    // ркЬрлЛ рккрк╣рлЗрк▓рк╛ркерлА рк░ркВркЧрк╛ркпрлЗрк▓рлЛ рк╣рлЛркп, ркдрлЛ ркХрк╛ркврлА ркирк╛ркЦрлЛ
                    shadedParts.splice(indexInArray, 1);
                } else {
                    // ркЬрлЛ рк░ркВркЧрк╛ркпрлЗрк▓рлЛ рки рк╣рлЛркп, ркдрлЛ ркЙркорлЗрк░рлЛ
                    shadedParts.push(segmentIndex);
                }
                drawShape(); // ркЕрккркбрлЗркЯ ркХрк░рлЗрк▓рлЛ ркЖркХрк╛рк░ рклрк░рлАркерлА ркжрлЛрк░рлЛ
            }
        }
        
        // ркХрлЗркирк╡рк╛рк╕ рккрк░ ркХрлНрк▓рк┐ркХ/ркЯркЪ ркЗрк╡рлЗркирлНркЯ рк╕рк╛ркВркнрк│ркирк╛рк░
        canvas.addEventListener('click', handleInteraction);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // ркбрк┐рклрлЛрк▓рлНркЯ рк╕рлНркХрлНрк░рлЛрк▓рк┐ркВркЧ ркЕркЯркХрк╛рк╡рлЛ
            handleInteraction(e);
        }, { passive: false });

        // ------------------------------------------------------------------
        // ркЬрк╡рк╛ркм ркдрккрк╛рк╕рлЛ
        // ------------------------------------------------------------------
        window.checkAnswer = function() {
            const requiredShades = currentQuestion.n;
            const userShades = shadedParts.length;

            if (userShades === requiredShades) {
                // рк╕рк╛ркЪрлЛ ркЬрк╡рк╛ркм
                score++;
                feedback.className = 'text-center text-lg font-bold text-green-600 mb-4';
                feedback.textContent = 'рк╕рк╛ркЪрлБркВ! ЁЯОЙ';
                
                // ркЖркЧрк╛ркорлА рккрлНрк░рк╢рлНрки ркорк╛ркЯрлЗ ркмркЯрки ркмркжрк▓рлЛ
                nextButton.textContent = 'ркЖркЧрк│ркирлЛ рккрлНрк░рк╢рлНрки';
                nextButton.onclick = loadNextQuestion;

            } else {
                // ркЦрлЛркЯрлЛ ркЬрк╡рк╛ркм
                feedback.className = 'text-center text-lg font-bold text-red-600 mb-4';
                feedback.textContent = `ркЦрлЛркЯрлБркВ. ркдркорк╛рк░рлЗ ${requiredShades} ркнрк╛ркЧ рк░ркВркЧрк╡рк╛ркирлА ркЬрк░рлВрк░ ркЫрлЗ. (${userShades} рк░ркВркЧрк╛ркпрлЗрк▓рк╛ ркЫрлЗ)`;
                // ркпрлБркЭрк░ркирлЗ рклрк░рлАркерлА рккрлНрк░ркпрк╛рк╕ ркХрк░рк╡рк╛ ркжрлЛ
                nextButton.textContent = 'рклрк░рлА рккрлНрк░ркпрк╛рк╕ ркХрк░рлЛ';
                nextButton.onclick = () => {
                    feedback.textContent = '';
                    nextButton.textContent = 'ркЬрк╡рк╛ркм ркдрккрк╛рк╕рлЛ';
                    nextButton.onclick = checkAnswer;
                }
            }
            scoreDisplay.textContent = score; // рк╕рлНркХрлЛрк░ ркЕрккркбрлЗркЯ ркХрк░рлЛ
        }

        // ------------------------------------------------------------------
        // рккрлНрк░рк╛рк░ркВркн
        // ------------------------------------------------------------------
        // ркХрлЗркирк╡рк╛рк╕ркирлБркВ ркХркж рк╕рлЗркЯ ркХрк░рлЛ ркЬрлЗркерлА ркдрлЗ рк░рк┐рк╕рлНрккрлЛркирлНрк╕рк┐рк╡ рк░рк╣рлЗ
        function resizeCanvas() {
            const containerWidth = canvas.parentElement.offsetWidth;
            const size = Math.min(containerWidth, 350); // ркорк╣ркдрлНркдрко 350px ркЕркерк╡рк╛ ркХркирлНркЯрлЗркирк░ркирлА рккрк╣рлЛрк│рк╛ркИ
            canvas.width = size;
            canvas.height = size;
            if (currentQuestion) {
                 drawShape(); // ркХркж ркмркжрк▓рк╛ркпрк╛ рккркЫрлА ркЖркХрк╛рк░ рклрк░рлАркерлА ркжрлЛрк░рлЛ
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // рк╢рк░рлВркЖркдркорк╛ркВ ркХркж рк╕рлЗркЯ ркХрк░рлЛ
        loadNextQuestion(); // рккрлНрк░ркерко рккрлНрк░рк╢рлНрки рк▓рлЛркб ркХрк░рлАркирлЗ рк░ркоркд рк╢рк░рлВ ркХрк░рлЛ
    </script>
</body>
</html>
